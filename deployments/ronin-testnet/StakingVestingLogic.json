{
  "abi": [
    {
      "type": "constructor",
      "inputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "blockProducerBlockBonus",
      "inputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "bridgeOperatorBlockBonus",
      "inputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "fastFinalityRewardPercentage",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "getContract",
      "inputs": [
        {
          "name": "contractType",
          "type": "uint8",
          "internalType": "enum ContractType"
        }
      ],
      "outputs": [
        {
          "name": "contract_",
          "type": "address",
          "internalType": "address payable"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "initialize",
      "inputs": [
        {
          "name": "validatorContract",
          "type": "address",
          "internalType": "address"
        },
        {
          "name": "blockProducerBonusPerBlock",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "bridgeOperatorBonusPerBlock",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "payable"
    },
    {
      "type": "function",
      "name": "initializeV2",
      "inputs": [],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "initializeV3",
      "inputs": [
        {
          "name": "fastFinalityRewardPercent",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "lastBlockSendingBonus",
      "inputs": [],
      "outputs": [
        {
          "name": "",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "view"
    },
    {
      "type": "function",
      "name": "receiveRON",
      "inputs": [],
      "outputs": [],
      "stateMutability": "payable"
    },
    {
      "type": "function",
      "name": "requestBonus",
      "inputs": [
        {
          "name": "forBlockProducer",
          "type": "bool",
          "internalType": "bool"
        },
        {
          "name": "forBridgeOperator",
          "type": "bool",
          "internalType": "bool"
        }
      ],
      "outputs": [
        {
          "name": "success",
          "type": "bool",
          "internalType": "bool"
        },
        {
          "name": "blockProducerBonus",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "bridgeOperatorBonus",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "fastFinalityRewardPercent",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setBlockProducerBonusPerBlock",
      "inputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setBridgeOperatorBonusPerBlock",
      "inputs": [
        {
          "name": "amount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setContract",
      "inputs": [
        {
          "name": "contractType",
          "type": "uint8",
          "internalType": "enum ContractType"
        },
        {
          "name": "addr",
          "type": "address",
          "internalType": "address"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "function",
      "name": "setFastFinalityRewardPercentage",
      "inputs": [
        {
          "name": "percent",
          "type": "uint256",
          "internalType": "uint256"
        }
      ],
      "outputs": [],
      "stateMutability": "nonpayable"
    },
    {
      "type": "event",
      "name": "BlockProducerBonusPerBlockUpdated",
      "inputs": [
        {
          "name": "",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "BonusTransferFailed",
      "inputs": [
        {
          "name": "blockNumber",
          "type": "uint256",
          "indexed": true,
          "internalType": "uint256"
        },
        {
          "name": "recipient",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "blockProducerAmount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        },
        {
          "name": "bridgeOperatorAmount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        },
        {
          "name": "contractBalance",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "BonusTransferred",
      "inputs": [
        {
          "name": "blockNumber",
          "type": "uint256",
          "indexed": true,
          "internalType": "uint256"
        },
        {
          "name": "recipient",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        },
        {
          "name": "blockProducerAmount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        },
        {
          "name": "bridgeOperatorAmount",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "BridgeOperatorBonusPerBlockUpdated",
      "inputs": [
        {
          "name": "",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "ContractUpdated",
      "inputs": [
        {
          "name": "contractType",
          "type": "uint8",
          "indexed": true,
          "internalType": "enum ContractType"
        },
        {
          "name": "addr",
          "type": "address",
          "indexed": true,
          "internalType": "address"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "FastFinalityRewardPercentageUpdated",
      "inputs": [
        {
          "name": "",
          "type": "uint256",
          "indexed": false,
          "internalType": "uint256"
        }
      ],
      "anonymous": false
    },
    {
      "type": "event",
      "name": "Initialized",
      "inputs": [
        {
          "name": "version",
          "type": "uint8",
          "indexed": false,
          "internalType": "uint8"
        }
      ],
      "anonymous": false
    },
    {
      "type": "error",
      "name": "ErrBonusAlreadySent",
      "inputs": []
    },
    {
      "type": "error",
      "name": "ErrContractTypeNotFound",
      "inputs": [
        {
          "name": "contractType",
          "type": "uint8",
          "internalType": "enum ContractType"
        }
      ]
    },
    {
      "type": "error",
      "name": "ErrInsufficientBalance",
      "inputs": [
        {
          "name": "msgSig",
          "type": "bytes4",
          "internalType": "bytes4"
        },
        {
          "name": "currentBalance",
          "type": "uint256",
          "internalType": "uint256"
        },
        {
          "name": "sendAmount",
          "type": "uint256",
          "internalType": "uint256"
        }
      ]
    },
    {
      "type": "error",
      "name": "ErrInvalidArguments",
      "inputs": [
        {
          "name": "msgSig",
          "type": "bytes4",
          "internalType": "bytes4"
        }
      ]
    },
    {
      "type": "error",
      "name": "ErrRecipientRevert",
      "inputs": [
        {
          "name": "msgSig",
          "type": "bytes4",
          "internalType": "bytes4"
        }
      ]
    },
    {
      "type": "error",
      "name": "ErrUnauthorized",
      "inputs": [
        {
          "name": "msgSig",
          "type": "bytes4",
          "internalType": "bytes4"
        },
        {
          "name": "expectedRole",
          "type": "uint8",
          "internalType": "enum RoleAccess"
        }
      ]
    },
    {
      "type": "error",
      "name": "ErrUnexpectedInternalCall",
      "inputs": [
        {
          "name": "msgSig",
          "type": "bytes4",
          "internalType": "bytes4"
        },
        {
          "name": "expectedContractType",
          "type": "uint8",
          "internalType": "enum ContractType"
        },
        {
          "name": "actual",
          "type": "address",
          "internalType": "address"
        }
      ]
    },
    {
      "type": "error",
      "name": "ErrZeroCodeContract",
      "inputs": [
        {
          "name": "addr",
          "type": "address",
          "internalType": "address"
        }
      ]
    }
  ],
  "absolutePath": "StakingVesting.sol",
  "address": "0x6d1D5bC8014fFbBC2FF0cF28E899eed7418A2Bf6",
  "ast": "",
  "blockNumber": 27813238,
  "bytecode": "0x6080604052348015600f57600080fd5b506016601a565b60e5565b600054600160a81b900460ff161560875760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff600160a01b9091048116101560e3576000805460ff60a01b191660ff60a01b17905560405160ff81527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b610d9b806100f46000396000f3fe6080604052600436106100dd5760003560e01c80637a1ac61e1161007f578063d8209d0711610059578063d8209d0714610207578063de981f1b14610229578063f13ba64414610261578063fa8674a11461028157600080fd5b80637a1ac61e146101b4578063865e6fd3146101c75780639e7cb051146101e757600080fd5b8063434a025d116100bb578063434a025d1461016a57806359f778df146101685780635cd8a76b1461017f57806367e9941c1461019457600080fd5b80630634f5b9146100e25780630d9160e7146101295780633c3d841014610148575b600080fd5b3480156100ee57600080fd5b506101026100fd366004610bb2565b6102a3565b60408051941515855260208501939093529183015260608201526080015b60405180910390f35b34801561013557600080fd5b506003545b604051908152602001610120565b34801561015457600080fd5b50610168610163366004610be5565b6103f5565b005b34801561017657600080fd5b5060045461013a565b34801561018b57600080fd5b50610168610502565b3480156101a057600080fd5b506101686101af366004610be5565b610631565b6101686101c2366004610c15565b610645565b3480156101d357600080fd5b506101686101e2366004610c57565b6107a4565b3480156101f357600080fd5b50610168610202366004610be5565b6107c3565b34801561021357600080fd5b5061013a610222366004610be5565b5060015490565b34801561023557600080fd5b50610249610244366004610c81565b61081e565b6040516001600160a01b039091168152602001610120565b34801561026d57600080fd5b5061016861027c366004610be5565b6108b2565b34801561028d57600080fd5b5061013a61029c366004610be5565b5060025490565b60008060008060086102b4816108c3565b60035443116102ef576040517fe5cf958000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b43600355866102ff576000610303565b6001545b935085610311576000610315565b6002545b600454909350915060006103298486610ca3565b905080156103e9573361033c8183610928565b9650866103a1576040805187815260208101879052478183015290516001600160a01b0383169143917f137e697384eeada9cf7614b88e4ac940aeff18d0fef7e86bce1abdc812b95e099181900360600190a350600094508493508392506103eb9050565b60408051878152602081018790526001600160a01b0383169143917f60200441f885b45b3b7f1fdc45a47bb0d0a0884a6a17722f8dd7232830de9bd2910160405180910390a3505b505b5092959194509250565b600054600390600160a81b900460ff16158015610420575060005460ff808316600160a01b90920416105b6104885760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b6000805460ff60a81b1960ff8416600160a01b021661ffff60a01b1990911617600160a81b1790556104b982610984565b6000805460ff60a81b1916905560405160ff821681527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050565b565b600054600290600160a81b900460ff1615801561052d575060005460ff808316600160a01b90920416105b6105905760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161047f565b6000805460ff60a81b1960ff8416600160a01b021661ffff60a01b1990911617600160a81b17908190556105cf906008906001600160a01b03166109b9565b600080547fffffffffffffffffffff00ff000000000000000000000000000000000000000016905560405160ff821681527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498906020015b60405180910390a150565b610639610a75565b61064281610ae9565b50565b600054600160a81b900460ff161580801561066d57506000546001600160a01b90910460ff16105b8061068e5750303b15801561068e5750600054600160a01b900460ff166001145b6106f15760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161047f565b600080547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff16600160a01b1790558015610739576000805460ff60a81b1916600160a81b1790555b6107446008856109b9565b61074d83610b1e565b61075682610ae9565b801561079e576000805460ff60a81b19169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050565b6107ac610a75565b6107b581610b53565b6107bf82826109b9565b5050565b6107cb610a75565b612710811115610815576040517f053265f10000000000000000000000000000000000000000000000000000000081526001600160e01b031960003516600482015260240161047f565b61064281610984565b60007fdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb600083601081111561085557610855610cca565b60ff1681526020810191909152604001600020546001600160a01b03169050806108ad57816040517f812281be00000000000000000000000000000000000000000000000000000000815260040161047f9190610cf4565b919050565b6108ba610a75565b61064281610b1e565b6108cc8161081e565b6001600160a01b0316336001600160a01b031614610642576000356001600160e01b03191681336040517f8383e63400000000000000000000000000000000000000000000000000000000815260040161047f93929190610d02565b6000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114610975576040519150601f19603f3d011682016040523d82523d6000602084013e61097a565b606091505b5090949350505050565b60048190556040518181527f2ab16834b71343f4e1d560b325168aef35dd575d15d84c31ef788e947709953690602001610626565b807fdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb60008460108111156109ef576109ef610cca565b60ff168152602081019190915260400160002080547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039283161790558116826010811115610a4857610a48610cca565b6040517f865d1c228a8ea13709cfe61f346f7ff67f1bbd4a18ff31ad3e7147350d317c5990600090a35050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03163314610500576000356001600160e01b03191660016040517f3e523c0000000000000000000000000000000000000000000000000000000000815260040161047f929190610d37565b60028190556040518181527f57a23b4b11f619fb9dea21a5a8115bb90103c1043eb3318d773558829d25f12c90602001610626565b60018190556040518181527f861f03c645467325a586235bb3155834f1dddf12413d0a802f416eb6d4035e6d90602001610626565b806001600160a01b03163b600003610642576040517f2ff1928c0000000000000000000000000000000000000000000000000000000081526001600160a01b038216600482015260240161047f565b803580151581146108ad57600080fd5b60008060408385031215610bc557600080fd5b610bce83610ba2565b9150610bdc60208401610ba2565b90509250929050565b600060208284031215610bf757600080fd5b5035919050565b80356001600160a01b03811681146108ad57600080fd5b600080600060608486031215610c2a57600080fd5b610c3384610bfe565b95602085013595506040909401359392505050565b8035601181106108ad57600080fd5b60008060408385031215610c6a57600080fd5b610c7383610c48565b9150610bdc60208401610bfe565b600060208284031215610c9357600080fd5b610c9c82610c48565b9392505050565b80820180821115610cc457634e487b7160e01b600052601160045260246000fd5b92915050565b634e487b7160e01b600052602160045260246000fd5b60118110610cf057610cf0610cca565b9052565b60208101610cc48284610ce0565b6001600160e01b03198416815260608101610d206020830185610ce0565b6001600160a01b0383166040830152949350505050565b6001600160e01b03198316815260408101600b8310610d5857610d58610cca565b826020830152939250505056fea2646970667358221220854b9cf855805a265f92d312df5e5434fac8e8f9098ea46d4c0afcff1eaaf06d64736f6c63430008190033",
  "callValue": 0,
  "chainId": 2021,
  "constructorArgs": "0x",
  "contractName": "StakingVesting",
  "deployedBytecode": "0x6080604052600436106100dd5760003560e01c80637a1ac61e1161007f578063d8209d0711610059578063d8209d0714610207578063de981f1b14610229578063f13ba64414610261578063fa8674a11461028157600080fd5b80637a1ac61e146101b4578063865e6fd3146101c75780639e7cb051146101e757600080fd5b8063434a025d116100bb578063434a025d1461016a57806359f778df146101685780635cd8a76b1461017f57806367e9941c1461019457600080fd5b80630634f5b9146100e25780630d9160e7146101295780633c3d841014610148575b600080fd5b3480156100ee57600080fd5b506101026100fd366004610bb2565b6102a3565b60408051941515855260208501939093529183015260608201526080015b60405180910390f35b34801561013557600080fd5b506003545b604051908152602001610120565b34801561015457600080fd5b50610168610163366004610be5565b6103f5565b005b34801561017657600080fd5b5060045461013a565b34801561018b57600080fd5b50610168610502565b3480156101a057600080fd5b506101686101af366004610be5565b610631565b6101686101c2366004610c15565b610645565b3480156101d357600080fd5b506101686101e2366004610c57565b6107a4565b3480156101f357600080fd5b50610168610202366004610be5565b6107c3565b34801561021357600080fd5b5061013a610222366004610be5565b5060015490565b34801561023557600080fd5b50610249610244366004610c81565b61081e565b6040516001600160a01b039091168152602001610120565b34801561026d57600080fd5b5061016861027c366004610be5565b6108b2565b34801561028d57600080fd5b5061013a61029c366004610be5565b5060025490565b60008060008060086102b4816108c3565b60035443116102ef576040517fe5cf958000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b43600355866102ff576000610303565b6001545b935085610311576000610315565b6002545b600454909350915060006103298486610ca3565b905080156103e9573361033c8183610928565b9650866103a1576040805187815260208101879052478183015290516001600160a01b0383169143917f137e697384eeada9cf7614b88e4ac940aeff18d0fef7e86bce1abdc812b95e099181900360600190a350600094508493508392506103eb9050565b60408051878152602081018790526001600160a01b0383169143917f60200441f885b45b3b7f1fdc45a47bb0d0a0884a6a17722f8dd7232830de9bd2910160405180910390a3505b505b5092959194509250565b600054600390600160a81b900460ff16158015610420575060005460ff808316600160a01b90920416105b6104885760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b6000805460ff60a81b1960ff8416600160a01b021661ffff60a01b1990911617600160a81b1790556104b982610984565b6000805460ff60a81b1916905560405160ff821681527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15050565b565b600054600290600160a81b900460ff1615801561052d575060005460ff808316600160a01b90920416105b6105905760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161047f565b6000805460ff60a81b1960ff8416600160a01b021661ffff60a01b1990911617600160a81b17908190556105cf906008906001600160a01b03166109b9565b600080547fffffffffffffffffffff00ff000000000000000000000000000000000000000016905560405160ff821681527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498906020015b60405180910390a150565b610639610a75565b61064281610ae9565b50565b600054600160a81b900460ff161580801561066d57506000546001600160a01b90910460ff16105b8061068e5750303b15801561068e5750600054600160a01b900460ff166001145b6106f15760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161047f565b600080547fffffffffffffffffffffff00ffffffffffffffffffffffffffffffffffffffff16600160a01b1790558015610739576000805460ff60a81b1916600160a81b1790555b6107446008856109b9565b61074d83610b1e565b61075682610ae9565b801561079e576000805460ff60a81b19169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050565b6107ac610a75565b6107b581610b53565b6107bf82826109b9565b5050565b6107cb610a75565b612710811115610815576040517f053265f10000000000000000000000000000000000000000000000000000000081526001600160e01b031960003516600482015260240161047f565b61064281610984565b60007fdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb600083601081111561085557610855610cca565b60ff1681526020810191909152604001600020546001600160a01b03169050806108ad57816040517f812281be00000000000000000000000000000000000000000000000000000000815260040161047f9190610cf4565b919050565b6108ba610a75565b61064281610b1e565b6108cc8161081e565b6001600160a01b0316336001600160a01b031614610642576000356001600160e01b03191681336040517f8383e63400000000000000000000000000000000000000000000000000000000815260040161047f93929190610d02565b6000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114610975576040519150601f19603f3d011682016040523d82523d6000602084013e61097a565b606091505b5090949350505050565b60048190556040518181527f2ab16834b71343f4e1d560b325168aef35dd575d15d84c31ef788e947709953690602001610626565b807fdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb60008460108111156109ef576109ef610cca565b60ff168152602081019190915260400160002080547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b039283161790558116826010811115610a4857610a48610cca565b6040517f865d1c228a8ea13709cfe61f346f7ff67f1bbd4a18ff31ad3e7147350d317c5990600090a35050565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103546001600160a01b03163314610500576000356001600160e01b03191660016040517f3e523c0000000000000000000000000000000000000000000000000000000000815260040161047f929190610d37565b60028190556040518181527f57a23b4b11f619fb9dea21a5a8115bb90103c1043eb3318d773558829d25f12c90602001610626565b60018190556040518181527f861f03c645467325a586235bb3155834f1dddf12413d0a802f416eb6d4035e6d90602001610626565b806001600160a01b03163b600003610642576040517f2ff1928c0000000000000000000000000000000000000000000000000000000081526001600160a01b038216600482015260240161047f565b803580151581146108ad57600080fd5b60008060408385031215610bc557600080fd5b610bce83610ba2565b9150610bdc60208401610ba2565b90509250929050565b600060208284031215610bf757600080fd5b5035919050565b80356001600160a01b03811681146108ad57600080fd5b600080600060608486031215610c2a57600080fd5b610c3384610bfe565b95602085013595506040909401359392505050565b8035601181106108ad57600080fd5b60008060408385031215610c6a57600080fd5b610c7383610c48565b9150610bdc60208401610bfe565b600060208284031215610c9357600080fd5b610c9c82610c48565b9392505050565b80820180821115610cc457634e487b7160e01b600052601160045260246000fd5b92915050565b634e487b7160e01b600052602160045260246000fd5b60118110610cf057610cf0610cca565b9052565b60208101610cc48284610ce0565b6001600160e01b03198416815260608101610d206020830185610ce0565b6001600160a01b0383166040830152949350505050565b6001600160e01b03198316815260408101600b8310610d5857610d58610cca565b826020830152939250505056fea2646970667358221220854b9cf855805a265f92d312df5e5434fac8e8f9098ea46d4c0afcff1eaaf06d64736f6c63430008190033",
  "deployer": "0x968D0Cd7343f711216817E617d3f92a23dC91c07",
  "devdoc": {
    "version": 1,
    "kind": "dev",
    "methods": {
      "blockProducerBlockBonus(uint256)": {
        "details": "Returns the bonus amount for the block producer at `blockNum`."
      },
      "bridgeOperatorBlockBonus(uint256)": {
        "details": "Returns the bonus amount for the bridge validator at `blockNum`."
      },
      "fastFinalityRewardPercentage()": {
        "details": "Returns the percentage of fast finality reward."
      },
      "getContract(uint8)": {
        "details": "Returns the address of a contract with a specific role. Throws an error if no contract is set for the specified role.",
        "params": {
          "contractType": "The role of the contract to retrieve."
        },
        "returns": {
          "contract_": "The address of the contract with the specified role."
        }
      },
      "initialize(address,uint256,uint256)": {
        "details": "Initializes the contract storage."
      },
      "lastBlockSendingBonus()": {
        "details": "Returns the last block number that the staking vesting is sent."
      },
      "receiveRON()": {
        "details": "Receives RON from any address."
      },
      "requestBonus(bool,bool)": {
        "details": "Transfers the staking vesting for the block producer and the bridge operator whenever a new block is mined. Requirements: - The method caller must be validator contract. - The method must be called only once per block. Emits the event `BonusTransferred` or `BonusTransferFailed`. Notes: - The method does not revert when the contract balance is insufficient to send bonus. This assure the submit reward method will not be reverted, and the underlying nodes does not hang.",
        "params": {
          "forBlockProducer": "Indicates whether requesting the bonus for the block procucer, in case of being in jail or relevance.",
          "forBridgeOperator": "Indicates whether requesting the bonus for the bridge operator."
        },
        "returns": {
          "blockProducerBonus": "The amount of bonus actually sent for the block producer, returns 0 when the transfer is failed.",
          "bridgeOperatorBonus": "The amount of bonus actually sent for the bridge operator, returns 0 when the transfer is failed.",
          "fastFinalityRewardPercent": "The percent of fast finality reward, returns 0 when the transfer is failed.",
          "success": "Whether the transfer is successfully. This returns false mostly because this contract is out of balance."
        }
      },
      "setBlockProducerBonusPerBlock(uint256)": {
        "details": "Sets the bonus amount per block for block producer. Emits the event `BlockProducerBonusPerBlockUpdated`. Requirements: - The method caller is admin."
      },
      "setBridgeOperatorBonusPerBlock(uint256)": {
        "details": "Sets the bonus amount per block for bridge operator. Emits the event `BridgeOperatorBonusPerBlockUpdated`. Requirements: - The method caller is admin."
      },
      "setContract(uint8,address)": {
        "details": "Sets the address of a contract with a specific role. Emits the event {ContractUpdated}.",
        "params": {
          "addr": "The address of the contract to set.",
          "contractType": "The role of the contract to set."
        }
      },
      "setFastFinalityRewardPercentage(uint256)": {
        "details": "Sets the percent of fast finality reward. Emits the event `FastFinalityRewardPercentageUpdated`. Requirements: - The method caller is admin."
      }
    },
    "events": {
      "BlockProducerBonusPerBlockUpdated(uint256)": {
        "details": "Emitted when the block bonus for block producer is updated"
      },
      "BonusTransferFailed(uint256,address,uint256,uint256,uint256)": {
        "details": "Emitted when the transfer of block bonus for block producer is failed."
      },
      "BonusTransferred(uint256,address,uint256,uint256)": {
        "details": "Emitted when the block bonus for block producer is transferred."
      },
      "BridgeOperatorBonusPerBlockUpdated(uint256)": {
        "details": "Emitted when the block bonus for bridge operator is updated"
      },
      "ContractUpdated(uint8,address)": {
        "details": "Emitted when a contract is updated."
      },
      "FastFinalityRewardPercentageUpdated(uint256)": {
        "details": "Emitted when the percent of fast finality reward is updated"
      },
      "Initialized(uint8)": {
        "details": "Triggered when the contract has been initialized or reinitialized."
      }
    },
    "errors": {
      "ErrBonusAlreadySent()": [
        {
          "details": "Error thrown when attempting to send a bonus that has already been sent."
        }
      ],
      "ErrContractTypeNotFound(uint8)": [
        {
          "details": "Error of invalid role."
        }
      ],
      "ErrInsufficientBalance(bytes4,uint256,uint256)": [
        {
          "details": "Error of sender has insufficient balance."
        }
      ],
      "ErrInvalidArguments(bytes4)": [
        {
          "details": "Error indicating that arguments are invalid."
        }
      ],
      "ErrRecipientRevert(bytes4)": [
        {
          "details": "Error of recipient not accepting RON when transfer RON."
        }
      ],
      "ErrUnauthorized(bytes4,uint8)": [
        {
          "details": "Error indicating that the caller is unauthorized to perform a specific function.",
          "params": {
            "expectedRole": "The role required to perform the function.",
            "msgSig": "The function signature (bytes4) that the caller is unauthorized to perform."
          }
        }
      ],
      "ErrUnexpectedInternalCall(bytes4,uint8,address)": [
        {
          "details": "Error indicating that the caller is unauthorized to perform a specific function.",
          "params": {
            "actual": "The actual address that called to the function.",
            "expectedContractType": "The contract type required to perform the function.",
            "msgSig": "The function signature (bytes4)."
          }
        }
      ],
      "ErrZeroCodeContract(address)": [
        {
          "details": "Error of set to non-contract."
        }
      ]
    }
  },
  "isFoundry": true,
  "metadata": "{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ErrBonusAlreadySent\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"}],\"name\":\"ErrContractTypeNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"msgSig\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sendAmount\",\"type\":\"uint256\"}],\"name\":\"ErrInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"msgSig\",\"type\":\"bytes4\"}],\"name\":\"ErrInvalidArguments\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"msgSig\",\"type\":\"bytes4\"}],\"name\":\"ErrRecipientRevert\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"msgSig\",\"type\":\"bytes4\"},{\"internalType\":\"enum RoleAccess\",\"name\":\"expectedRole\",\"type\":\"uint8\"}],\"name\":\"ErrUnauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"msgSig\",\"type\":\"bytes4\"},{\"internalType\":\"enum ContractType\",\"name\":\"expectedContractType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"actual\",\"type\":\"address\"}],\"name\":\"ErrUnexpectedInternalCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ErrZeroCodeContract\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BlockProducerBonusPerBlockUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockProducerAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bridgeOperatorAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"contractBalance\",\"type\":\"uint256\"}],\"name\":\"BonusTransferFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockProducerAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bridgeOperatorAmount\",\"type\":\"uint256\"}],\"name\":\"BonusTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"BridgeOperatorBonusPerBlockUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"FastFinalityRewardPercentageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blockProducerBlockBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bridgeOperatorBlockBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fastFinalityRewardPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"}],\"name\":\"getContract\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"contract_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"validatorContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockProducerBonusPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeOperatorBonusPerBlock\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fastFinalityRewardPercent\",\"type\":\"uint256\"}],\"name\":\"initializeV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBlockSendingBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiveRON\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"forBlockProducer\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"forBridgeOperator\",\"type\":\"bool\"}],\"name\":\"requestBonus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"blockProducerBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeOperatorBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fastFinalityRewardPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBlockProducerBonusPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBridgeOperatorBonusPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ContractType\",\"name\":\"contractType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setFastFinalityRewardPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ErrBonusAlreadySent()\":[{\"details\":\"Error thrown when attempting to send a bonus that has already been sent.\"}],\"ErrContractTypeNotFound(uint8)\":[{\"details\":\"Error of invalid role.\"}],\"ErrInsufficientBalance(bytes4,uint256,uint256)\":[{\"details\":\"Error of sender has insufficient balance.\"}],\"ErrInvalidArguments(bytes4)\":[{\"details\":\"Error indicating that arguments are invalid.\"}],\"ErrRecipientRevert(bytes4)\":[{\"details\":\"Error of recipient not accepting RON when transfer RON.\"}],\"ErrUnauthorized(bytes4,uint8)\":[{\"details\":\"Error indicating that the caller is unauthorized to perform a specific function.\",\"params\":{\"expectedRole\":\"The role required to perform the function.\",\"msgSig\":\"The function signature (bytes4) that the caller is unauthorized to perform.\"}}],\"ErrUnexpectedInternalCall(bytes4,uint8,address)\":[{\"details\":\"Error indicating that the caller is unauthorized to perform a specific function.\",\"params\":{\"actual\":\"The actual address that called to the function.\",\"expectedContractType\":\"The contract type required to perform the function.\",\"msgSig\":\"The function signature (bytes4).\"}}],\"ErrZeroCodeContract(address)\":[{\"details\":\"Error of set to non-contract.\"}]},\"events\":{\"BlockProducerBonusPerBlockUpdated(uint256)\":{\"details\":\"Emitted when the block bonus for block producer is updated\"},\"BonusTransferFailed(uint256,address,uint256,uint256,uint256)\":{\"details\":\"Emitted when the transfer of block bonus for block producer is failed.\"},\"BonusTransferred(uint256,address,uint256,uint256)\":{\"details\":\"Emitted when the block bonus for block producer is transferred.\"},\"BridgeOperatorBonusPerBlockUpdated(uint256)\":{\"details\":\"Emitted when the block bonus for bridge operator is updated\"},\"ContractUpdated(uint8,address)\":{\"details\":\"Emitted when a contract is updated.\"},\"FastFinalityRewardPercentageUpdated(uint256)\":{\"details\":\"Emitted when the percent of fast finality reward is updated\"},\"Initialized(uint8)\":{\"details\":\"Triggered when the contract has been initialized or reinitialized.\"}},\"kind\":\"dev\",\"methods\":{\"blockProducerBlockBonus(uint256)\":{\"details\":\"Returns the bonus amount for the block producer at `blockNum`.\"},\"bridgeOperatorBlockBonus(uint256)\":{\"details\":\"Returns the bonus amount for the bridge validator at `blockNum`.\"},\"fastFinalityRewardPercentage()\":{\"details\":\"Returns the percentage of fast finality reward.\"},\"getContract(uint8)\":{\"details\":\"Returns the address of a contract with a specific role. Throws an error if no contract is set for the specified role.\",\"params\":{\"contractType\":\"The role of the contract to retrieve.\"},\"returns\":{\"contract_\":\"The address of the contract with the specified role.\"}},\"initialize(address,uint256,uint256)\":{\"details\":\"Initializes the contract storage.\"},\"lastBlockSendingBonus()\":{\"details\":\"Returns the last block number that the staking vesting is sent.\"},\"receiveRON()\":{\"details\":\"Receives RON from any address.\"},\"requestBonus(bool,bool)\":{\"details\":\"Transfers the staking vesting for the block producer and the bridge operator whenever a new block is mined. Requirements: - The method caller must be validator contract. - The method must be called only once per block. Emits the event `BonusTransferred` or `BonusTransferFailed`. Notes: - The method does not revert when the contract balance is insufficient to send bonus. This assure the submit reward method will not be reverted, and the underlying nodes does not hang.\",\"params\":{\"forBlockProducer\":\"Indicates whether requesting the bonus for the block procucer, in case of being in jail or relevance.\",\"forBridgeOperator\":\"Indicates whether requesting the bonus for the bridge operator.\"},\"returns\":{\"blockProducerBonus\":\"The amount of bonus actually sent for the block producer, returns 0 when the transfer is failed.\",\"bridgeOperatorBonus\":\"The amount of bonus actually sent for the bridge operator, returns 0 when the transfer is failed.\",\"fastFinalityRewardPercent\":\"The percent of fast finality reward, returns 0 when the transfer is failed.\",\"success\":\"Whether the transfer is successfully. This returns false mostly because this contract is out of balance.\"}},\"setBlockProducerBonusPerBlock(uint256)\":{\"details\":\"Sets the bonus amount per block for block producer. Emits the event `BlockProducerBonusPerBlockUpdated`. Requirements: - The method caller is admin.\"},\"setBridgeOperatorBonusPerBlock(uint256)\":{\"details\":\"Sets the bonus amount per block for bridge operator. Emits the event `BridgeOperatorBonusPerBlockUpdated`. Requirements: - The method caller is admin.\"},\"setContract(uint8,address)\":{\"details\":\"Sets the address of a contract with a specific role. Emits the event {ContractUpdated}.\",\"params\":{\"addr\":\"The address of the contract to set.\",\"contractType\":\"The role of the contract to set.\"}},\"setFastFinalityRewardPercentage(uint256)\":{\"details\":\"Sets the percent of fast finality reward. Emits the event `FastFinalityRewardPercentageUpdated`. Requirements: - The method caller is admin.\"}},\"stateVariables\":{\"_blockProducerBonusPerBlock\":{\"details\":\"The block bonus for the block producer whenever a new block is mined.\"},\"_bridgeOperatorBonusPerBlock\":{\"details\":\"The block bonus for the bridge operator whenever a new block is mined.\"},\"_fastFinalityRewardPercentage\":{\"details\":\"The percentage that extracted from reward of block producer for fast finality.\"},\"_lastBlockSendingBonus\":{\"details\":\"The last block number that the staking vesting sent.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ronin/StakingVesting.sol\":\"StakingVesting\"},\"evmVersion\":\"berlin\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[\":@chainlink/contracts/=lib/chainlink/contracts/\",\":@contract-libs/=lib/foundry-deployment-kit/lib/contract-libs/src/\",\":@fdk/=lib/foundry-deployment-kit/script/\",\":@openzeppelin-v5/contracts/=lib/oz-v5/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":@prb/math/=lib/prb-math/\",\":@prb/test/=lib/prb-test/src/\",\":@ronin/contracts/=contracts/\",\":@ronin/test/=test/foundry/\",\":@solady/=lib/foundry-deployment-kit/lib/solady/src/\",\":chainlink/=lib/chainlink/\",\":contract-libs/=lib/contract-libs/src/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/oz-v5/lib/erc4626-tests/\",\":forge-std/=lib/foundry-deployment-kit/lib/forge-std/src/\",\":foundry-deployment-kit/=lib/foundry-deployment-kit/\",\":hardhat/=node_modules/hardhat/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/foundry-deployment-kit/lib/openzeppelin-contracts/contracts/\",\":oz-v5/=lib/oz-v5/contracts/\",\":prb-math/=lib/prb-math/src/\",\":prb-test/=lib/prb-test/src/\",\":safe-smart-account/contracts/=lib/safe-smart-account/contracts/\",\":sample-projects/=node_modules/hardhat/sample-projects/\",\":solady/=lib/foundry-deployment-kit/lib/solady/src/\"]},\"sources\":{\"contracts/extensions/RONTransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nabstract contract RONTransferHelper {\\n  /// @dev Error of sender has insufficient balance.\\n  error ErrInsufficientBalance(bytes4 msgSig, uint256 currentBalance, uint256 sendAmount);\\n  /// @dev Error of recipient not accepting RON when transfer RON.\\n  error ErrRecipientRevert(bytes4 msgSig);\\n\\n  /**\\n   * @dev See `_sendRON`.\\n   * Reverts if the recipient does not receive RON.\\n   */\\n  function _transferRON(address payable recipient, uint256 amount) internal {\\n    if (!_sendRON(recipient, amount)) revert ErrRecipientRevert(msg.sig);\\n  }\\n\\n  /**\\n   * @dev Send `amount` RON to the address `recipient`.\\n   * Returns whether the recipient receives RON or not.\\n   * Reverts once the contract balance is insufficient.\\n   *\\n   * Note: consider using `ReentrancyGuard` before calling this function.\\n   *\\n   */\\n  function _sendRON(address payable recipient, uint256 amount) internal returns (bool success) {\\n    if (address(this).balance < amount) revert ErrInsufficientBalance(msg.sig, address(this).balance, amount);\\n    return _unsafeSendRON(recipient, amount);\\n  }\\n\\n  /**\\n   * @dev Unsafe send `amount` RON to the address `recipient`. If the sender's balance is insufficient,\\n   * the call does not revert.\\n   *\\n   * Note:\\n   * - Does not assert whether the balance of sender is sufficient.\\n   * - Does not assert whether the recipient accepts RON.\\n   * - Consider using `ReentrancyGuard` before calling this function.\\n   *\\n   */\\n  function _unsafeSendRON(address payable recipient, uint256 amount) internal returns (bool success) {\\n    (success,) = recipient.call{ value: amount }(\\\"\\\");\\n  }\\n\\n  /**\\n   * @dev Same purpose with {_unsafeSendRONLimitGas(address,uin256)} but containing gas limit stipend forwarded in the call.\\n   */\\n  function _unsafeSendRONLimitGas(\\n    address payable recipient,\\n    uint256 amount,\\n    uint256 gas\\n  ) internal returns (bool success) {\\n    // When msg.value = 0, the forwarding gas will not be auto-added 2300.\\n    // We add an extra 2300 to make sure all calls will have the same amount of gas.\\n    if (amount == 0) {\\n      gas += 2300;\\n    }\\n\\n    (success,) = recipient.call{ value: amount, gas: gas }(\\\"\\\");\\n  }\\n}\\n\",\"keccak256\":\"0x6c22ff06a40c3aee46c15c29f429d4a7e785824209264ff379c4901604a08dfd\",\"license\":\"MIT\"},\"contracts/extensions/TransparentUpgradeableProxyV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\\\";\\n\\ncontract TransparentUpgradeableProxyV2 is TransparentUpgradeableProxy {\\n  constructor(\\n    address _logic,\\n    address admin_,\\n    bytes memory _data\\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) { }\\n\\n  /**\\n   * @dev Calls a function from the current implementation as specified by `_data`, which should be an encoded function call.\\n   *\\n   * Requirements:\\n   * - Only the admin can call this function.\\n   *\\n   * Note: The proxy admin is not allowed to interact with the proxy logic through the fallback function to avoid\\n   * triggering some unexpected logic. This is to allow the administrator to explicitly call the proxy, please consider\\n   * reviewing the encoded data `_data` and the method which is called before using this.\\n   *\\n   */\\n  function functionDelegateCall(bytes memory _data) public payable ifAdmin {\\n    address _addr = _implementation();\\n    assembly {\\n      let _result := delegatecall(gas(), _addr, add(_data, 32), mload(_data), 0, 0)\\n      returndatacopy(0, 0, returndatasize())\\n      switch _result\\n      case 0 { revert(0, returndatasize()) }\\n      default { return(0, returndatasize()) }\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xeac1fc1818ca3720fff47e43270accaee506dbedabc25a4f67476d49bd6ef7f3\",\"license\":\"MIT\"},\"contracts/extensions/collections/HasContracts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { HasProxyAdmin } from \\\"./HasProxyAdmin.sol\\\";\\nimport \\\"../../interfaces/collections/IHasContracts.sol\\\";\\nimport { IdentityGuard } from \\\"../../utils/IdentityGuard.sol\\\";\\nimport { ErrUnexpectedInternalCall } from \\\"../../utils/CommonErrors.sol\\\";\\n\\n/**\\n * @title HasContracts\\n * @dev A contract that provides functionality to manage multiple contracts with different roles.\\n */\\nabstract contract HasContracts is HasProxyAdmin, IHasContracts, IdentityGuard {\\n  /// @dev value is equal to keccak256(\\\"@ronin.dpos.collections.HasContracts.slot\\\") - 1\\n  bytes32 private constant _STORAGE_SLOT = 0xdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb;\\n\\n  /**\\n   * @dev Modifier to restrict access to functions only to contracts with a specific role.\\n   * @param contractType The contract type that allowed to call\\n   */\\n  modifier onlyContract(ContractType contractType) virtual {\\n    _requireContract(contractType);\\n    _;\\n  }\\n\\n  /**\\n   * @inheritdoc IHasContracts\\n   */\\n  function setContract(ContractType contractType, address addr) external virtual onlyAdmin {\\n    _requireHasCode(addr);\\n    _setContract(contractType, addr);\\n  }\\n\\n  /**\\n   * @inheritdoc IHasContracts\\n   */\\n  function getContract(ContractType contractType) public view returns (address payable contract_) {\\n    contract_ = payable(_getContractMap()[uint8(contractType)]);\\n    if (contract_ == address(0)) revert ErrContractTypeNotFound(contractType);\\n  }\\n\\n  /**\\n   * @dev Internal function to set the address of a contract with a specific role.\\n   * @param contractType The contract type of the contract to set.\\n   * @param addr The address of the contract to set.\\n   */\\n  function _setContract(ContractType contractType, address addr) internal virtual {\\n    _getContractMap()[uint8(contractType)] = addr;\\n    emit ContractUpdated(contractType, addr);\\n  }\\n\\n  /**\\n   * @dev Internal function to access the mapping of contract addresses with roles.\\n   * @return contracts_ The mapping of contract addresses with roles.\\n   */\\n  function _getContractMap() private pure returns (mapping(uint8 => address) storage contracts_) {\\n    assembly {\\n      contracts_.slot := _STORAGE_SLOT\\n    }\\n  }\\n\\n  /**\\n   * @dev Internal function to check if the calling contract has a specific role.\\n   * @param contractType The contract type that the calling contract must have.\\n   * @dev Throws an error if the calling contract does not have the specified role.\\n   */\\n  function _requireContract(ContractType contractType) private view {\\n    if (msg.sender != getContract(contractType)) {\\n      revert ErrUnexpectedInternalCall(msg.sig, contractType, msg.sender);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x53b9c2c44f39fa16fd4582b4667e808b8ab7c43437c263b59b5cbf5d2df47e78\",\"license\":\"MIT\"},\"contracts/extensions/collections/HasProxyAdmin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\nimport \\\"../../utils/CommonErrors.sol\\\";\\n\\nabstract contract HasProxyAdmin {\\n  // bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n  bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n  modifier onlyAdmin() {\\n    _requireAdmin();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Returns proxy admin.\\n   */\\n  function _getAdmin() internal view virtual returns (address) {\\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n  }\\n\\n  function _requireAdmin() internal view {\\n    if (msg.sender != _getAdmin()) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\\n  }\\n}\\n\",\"keccak256\":\"0x0916021d04ea0c93c54978dc2fd46575fd2bd867369fbf9ce49f316939ddaf25\",\"license\":\"MIT\"},\"contracts/extensions/consumers/PercentageConsumer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract PercentageConsumer {\\n  uint256 internal constant _MAX_PERCENTAGE = 100_00;\\n}\\n\",\"keccak256\":\"0x5dc54a24348c5d614de1b4805dddeab4dda72f9f0636b27bf0ed295fee017dcf\",\"license\":\"MIT\"},\"contracts/interfaces/IStakingVesting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\ninterface IStakingVesting {\\n  /**\\n   * @dev Error thrown when attempting to send a bonus that has already been sent.\\n   */\\n  error ErrBonusAlreadySent();\\n\\n  /// @dev Emitted when the block bonus for block producer is transferred.\\n  event BonusTransferred(\\n    uint256 indexed blockNumber, address indexed recipient, uint256 blockProducerAmount, uint256 bridgeOperatorAmount\\n  );\\n  /// @dev Emitted when the transfer of block bonus for block producer is failed.\\n  event BonusTransferFailed(\\n    uint256 indexed blockNumber,\\n    address indexed recipient,\\n    uint256 blockProducerAmount,\\n    uint256 bridgeOperatorAmount,\\n    uint256 contractBalance\\n  );\\n  /// @dev Emitted when the block bonus for block producer is updated\\n  event BlockProducerBonusPerBlockUpdated(uint256);\\n  /// @dev Emitted when the block bonus for bridge operator is updated\\n  event BridgeOperatorBonusPerBlockUpdated(uint256);\\n  /// @dev Emitted when the percent of fast finality reward is updated\\n  event FastFinalityRewardPercentageUpdated(uint256);\\n\\n  /**\\n   * @dev Returns the bonus amount for the block producer at `blockNum`.\\n   */\\n  function blockProducerBlockBonus(uint256 blockNum) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the bonus amount for the bridge validator at `blockNum`.\\n   */\\n  function bridgeOperatorBlockBonus(uint256 blockNum) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the percentage of fast finality reward.\\n   */\\n  function fastFinalityRewardPercentage() external view returns (uint256);\\n\\n  /**\\n   * @dev Receives RON from any address.\\n   */\\n  function receiveRON() external payable;\\n\\n  /**\\n   * @dev Returns the last block number that the staking vesting is sent.\\n   */\\n  function lastBlockSendingBonus() external view returns (uint256);\\n\\n  /**\\n   * @dev Transfers the staking vesting for the block producer and the bridge operator whenever a new block is mined.\\n   *\\n   * Requirements:\\n   * - The method caller must be validator contract.\\n   * - The method must be called only once per block.\\n   *\\n   * Emits the event `BonusTransferred` or `BonusTransferFailed`.\\n   *\\n   * Notes:\\n   * - The method does not revert when the contract balance is insufficient to send bonus. This assure the submit reward method\\n   * will not be reverted, and the underlying nodes does not hang.\\n   *\\n   * @param forBlockProducer Indicates whether requesting the bonus for the block procucer, in case of being in jail or relevance.\\n   * @param forBridgeOperator Indicates whether requesting the bonus for the bridge operator.\\n   *\\n   * @return success Whether the transfer is successfully. This returns false mostly because this contract is out of balance.\\n   * @return blockProducerBonus The amount of bonus actually sent for the block producer, returns 0 when the transfer is failed.\\n   * @return bridgeOperatorBonus The amount of bonus actually sent for the bridge operator, returns 0 when the transfer is failed.\\n   * @return fastFinalityRewardPercentage The percent of fast finality reward, returns 0 when the transfer is failed.\\n   *\\n   */\\n  function requestBonus(\\n    bool forBlockProducer,\\n    bool forBridgeOperator\\n  )\\n    external\\n    returns (\\n      bool success,\\n      uint256 blockProducerBonus,\\n      uint256 bridgeOperatorBonus,\\n      uint256 fastFinalityRewardPercentage\\n    );\\n\\n  /**\\n   * @dev Sets the bonus amount per block for block producer.\\n   *\\n   * Emits the event `BlockProducerBonusPerBlockUpdated`.\\n   *\\n   * Requirements:\\n   * - The method caller is admin.\\n   *\\n   */\\n  function setBlockProducerBonusPerBlock(uint256 amount) external;\\n\\n  /**\\n   * @dev Sets the bonus amount per block for bridge operator.\\n   *\\n   * Emits the event `BridgeOperatorBonusPerBlockUpdated`.\\n   *\\n   * Requirements:\\n   * - The method caller is admin.\\n   *\\n   */\\n  function setBridgeOperatorBonusPerBlock(uint256 _amount) external;\\n\\n  /**\\n   * @dev Sets the percent of fast finality reward.\\n   *\\n   * Emits the event `FastFinalityRewardPercentageUpdated`.\\n   *\\n   * Requirements:\\n   * - The method caller is admin.\\n   *\\n   */\\n  function setFastFinalityRewardPercentage(uint256 _percent) external;\\n}\\n\",\"keccak256\":\"0xaa10f1a77d697529d548fac81d89ae553c535e59c6258dfa22390c28ca702cdd\",\"license\":\"MIT\"},\"contracts/interfaces/collections/IHasContracts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nimport { ContractType } from \\\"../../utils/ContractType.sol\\\";\\n\\ninterface IHasContracts {\\n  /// @dev Error of invalid role.\\n  error ErrContractTypeNotFound(ContractType contractType);\\n\\n  /// @dev Emitted when a contract is updated.\\n  event ContractUpdated(ContractType indexed contractType, address indexed addr);\\n\\n  /**\\n   * @dev Returns the address of a contract with a specific role.\\n   * Throws an error if no contract is set for the specified role.\\n   *\\n   * @param contractType The role of the contract to retrieve.\\n   * @return contract_ The address of the contract with the specified role.\\n   */\\n  function getContract(ContractType contractType) external view returns (address payable contract_);\\n\\n  /**\\n   * @dev Sets the address of a contract with a specific role.\\n   * Emits the event {ContractUpdated}.\\n   * @param contractType The role of the contract to set.\\n   * @param addr The address of the contract to set.\\n   */\\n  function setContract(ContractType contractType, address addr) external;\\n}\\n\",\"keccak256\":\"0x3cb6bc67853229163685bbba63469fb2ef103bf1cbfec0fed3e9e4686049f45b\",\"license\":\"MIT\"},\"contracts/libraries/LibArray.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IndexMap } from \\\"./LibIndexMap.sol\\\";\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n/**\\n * @title LibArray\\n * @dev A library for array-related utility functions in Solidity.\\n */\\nlibrary LibArray {\\n  /**\\n   * @dev Error indicating a length mismatch between two arrays.\\n   */\\n  error ErrLengthMismatch();\\n\\n  /**\\n   * @dev Error thrown when a duplicated element is detected in an array.\\n   * @param msgSig The function signature that invoke the error.\\n   */\\n  error ErrDuplicated(bytes4 msgSig);\\n\\n  /**\\n   * @dev Calculates the sum of an array of uint256 values.\\n   *\\n   * Modified from: https://docs.soliditylang.org/en/v0.8.25/assembly.html#example\\n   *\\n   * @param data The array of uint256 values for which the sum is calculated.\\n   * @return result The sum of the provided array.\\n   */\\n  function sum(uint256[] memory data) internal pure returns (uint256 result) {\\n    assembly (\\\"memory-safe\\\") {\\n      // Load the length (first 32 bytes)\\n      let len := mload(data)\\n      let dataElementLocation := add(data, 0x20)\\n\\n      // Iterate until the bound is not met.\\n      for { let end := add(dataElementLocation, mul(len, 0x20)) } lt(dataElementLocation, end) {\\n        dataElementLocation := add(dataElementLocation, 0x20)\\n      } { result := add(result, mload(dataElementLocation)) }\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns whether or not there's a duplicate. Runs in O(n^2).\\n   * @param A Array to search\\n   * @return Returns true if duplicate, false otherwise\\n   */\\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\\n    uint256 length = A.length;\\n    if (length == 0) return false;\\n\\n    unchecked {\\n      for (uint256 i; i < length - 1; ++i) {\\n        for (uint256 j = i + 1; j < length; ++j) {\\n          if (A[i] == A[j]) {\\n            return true;\\n          }\\n        }\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  /**\\n   * @notice This method normalized the descending-sorted array `values` so that all elements in the `values`\\n   * are still in correct order, have 'relative' diffs and not greater than `sum(normed(values))/divisor`.\\n   * Returns the `normSum` and the `pivot` after normalizing the array.\\n   *\\n   * @dev Given a tuple of `(a, s, k)` and divisor `d` where:\\n   *    - `a` is the array of values of length `n`,\\n   *    - `s` is the sum of the array,\\n   *    - `k` is the pivot value, `k = s / d` initially.\\n   *\\n   * This method normalizes `a` to `a'` such that:\\n   *    (1) Elements in `a` and `a'` are decreased relatively\\n   *    (2) `k' = (s' / d)` and `\\u2200x \\u2208 a': x \\u2264 k'`\\n   *\\n   * Algorithm:\\n   *    1. Init `s = sum(a)`, `k = s/d`.\\n   *    2. While `k` changes:\\n   *       * Replace all `a[i] > k` by `k`\\n   *       * k := sum(unchanged(a[i])) / (d - count(changed(a[i])))\\n   *\\n   * For example:\\n   *    Input:\\n   *      a = [100, 70, 20, 15, 3]\\n   *      d = 3\\n   *    Calculation:\\n   *      Init:    a = [ 100,  70,  20,  15,  3 ];    s = 208;   k = 69\\n   *      Round 1: a = [  69,  69,  20,  15,  3 ];    s = 177;   k = 38\\n   *      Round 2: a = [  38,  38,  20,  15,  3 ];    s = 114;   k = 38\\n   *\\n   *      The calculation stop since all elements in a is \\u2264 k, in other words, `k` is unchanged.\\n   *    Output:\\n   *      s = 114\\n   *      k = 38\\n   *\\n   * Implementation denotes:\\n   *    `pivot`: k\\n   *    `left`:  to-be-changed elements\\n   *    `right`: unchanged elements\\n   *\\n   *    Input:\\n   *                     pivot\\n   *                       v\\n   *            --*-----*--|--------*---------*--------*------\\n   *              ^     ^           ^         ^        ^\\n   *              a[0]  a[1]        a[2]      a[3]     a[4]\\n   *\\n   *    Output:\\n   *                         pivot = a[0] = a[1]\\n   *                           v\\n   *            ---------------|----*---------*--------*------\\n   *                                ^         ^        ^\\n   *                                a[2]      a[3]     a[4]\\n   *\\n   *\\n   */\\n  function findNormalizedSumAndPivot(\\n    uint256[] memory values,\\n    uint256 divisor\\n  ) internal pure returns (uint256 normSum, uint256 pivot) {\\n    divisor = Math.min(values.length, divisor);\\n    values = inplaceDescSort(values);\\n\\n    uint256 sLeft;\\n    uint256 nLeft;\\n    uint256 sRight;\\n    bool shouldExit;\\n\\n    normSum = sum(values);\\n    pivot = normSum / divisor;\\n\\n    while (!shouldExit) {\\n      shouldExit = true;\\n\\n      while (values[nLeft] > pivot) {\\n        sLeft += values[nLeft++];\\n        shouldExit = false;\\n      }\\n\\n      if (shouldExit) break;\\n\\n      sRight = normSum - sLeft;\\n      pivot = sRight / (divisor - nLeft); // Mathematically proven `divisor` is always larger than `nLeft`\\n      sLeft = pivot * nLeft;\\n      normSum = sRight + sLeft;\\n    }\\n  }\\n\\n  /**\\n   * @dev Clips the values in the given array to be within the specified lower and upper bounds.\\n   *\\n   * - The input array is modified in place.\\n   *\\n   * - Examples:\\n   * `inplaceClip([1, 2, 3, 4, 5], 2, 4)` => `[2, 2, 3, 4, 4]`\\n   */\\n  function inplaceClip(\\n    uint256[] memory values,\\n    uint256 lower,\\n    uint256 upper\\n  ) internal pure returns (uint256[] memory clippedValues) {\\n    uint256 length = values.length;\\n\\n    for (uint256 i; i < length; ++i) {\\n      if (values[i] < lower) values[i] = lower;\\n      if (values[i] > upper) values[i] = upper;\\n    }\\n\\n    assembly (\\\"memory-safe\\\") {\\n      clippedValues := values\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns whether two arrays of addresses are equal or not.\\n   */\\n  function isEqual(address[] memory self, address[] memory other) internal pure returns (bool yes) {\\n    return hash(self) == hash(other);\\n  }\\n\\n  /**\\n   * @dev Hash dynamic size array\\n   * @param self The array of uint256\\n   * @return digest The hash result of the array\\n   */\\n  function hash(uint256[] memory self) internal pure returns (bytes32 digest) {\\n    assembly (\\\"memory-safe\\\") {\\n      digest := keccak256(add(self, 0x20), mul(mload(self), 0x20))\\n    }\\n  }\\n\\n  function hash(address[] memory self) internal pure returns (bytes32 digest) {\\n    return hash(toUint256s(self));\\n  }\\n\\n  /**\\n   * @dev Return the concatenated array (uint256) from a and b.\\n   */\\n  function concat(uint256[] memory a, uint256[] memory b) internal pure returns (uint256[] memory c) {\\n    unchecked {\\n      uint256 lengthA = a.length;\\n      uint256 lengthB = b.length;\\n\\n      if (lengthA == 0) return b;\\n      if (lengthB == 0) return a;\\n\\n      c = new uint256[](lengthA + lengthB);\\n\\n      uint256 i;\\n\\n      for (; i < lengthA;) {\\n        c[i] = a[i];\\n        ++i;\\n      }\\n      for (uint256 j; j < lengthB;) {\\n        c[i] = b[j];\\n        ++i;\\n        ++j;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Return the concatenated array (address) from a and b.\\n   */\\n  function concat(address[] memory a, address[] memory b) internal pure returns (address[] memory c) {\\n    return unsafeToAddresses(concat(toUint256s(a), toUint256s(b)));\\n  }\\n\\n  /**\\n   * @dev Converts an array of address to an array of uint256.\\n   */\\n  function toUint256s(address[] memory self) internal pure returns (uint256[] memory uint256s) {\\n    assembly (\\\"memory-safe\\\") {\\n      uint256s := self\\n    }\\n  }\\n\\n  /**\\n   * @dev Converts an array of uint256 to an array of uint96.\\n   */\\n  function unsafeToUint96s(uint256[] memory self) internal pure returns (uint96[] memory uint96s) {\\n    assembly (\\\"memory-safe\\\") {\\n      uint96s := self\\n    }\\n  }\\n\\n  /**\\n   * @dev Converts an array of uint256 to an array of address.\\n   */\\n  function unsafeToAddresses(uint256[] memory self) internal pure returns (address[] memory addresses) {\\n    assembly (\\\"memory-safe\\\") {\\n      addresses := self\\n    }\\n  }\\n\\n  /**\\n   * @dev Create an array of indices (an index array) with provided range.\\n   * @param length The array size\\n   * @return data an array of indices\\n   */\\n  function arange(uint256 length) internal pure returns (uint256[] memory data) {\\n    unchecked {\\n      data = new uint256[](length);\\n      for (uint256 i; i < length; ++i) {\\n        data[i] = i;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Take elements from an array (uint256) given an array of indices.\\n   *\\n   * Inspiration from: https://numpy.org/doc/stable/reference/generated/numpy.take.html\\n   */\\n  function take(uint256[] memory self, uint256[] memory ids) internal pure returns (uint256[] memory result) {\\n    uint256 length = ids.length;\\n    result = new uint256[](length);\\n    for (uint256 i; i < length; ++i) {\\n      result[i] = self[ids[i]];\\n    }\\n  }\\n\\n  /**\\n   * @dev Take elements from an array (address) given an array of indices.\\n   */\\n  function take(address[] memory self, uint256[] memory indices) internal pure returns (address[] memory result) {\\n    return unsafeToAddresses(take(toUint256s(self), indices));\\n  }\\n\\n  /**\\n   * @dev Pick the top `k` `keys` of type address[] based on their corresponding `values`.\\n   */\\n  function pickTopKByValues(\\n    address[] memory keys,\\n    uint256[] memory values,\\n    uint256 k\\n  ) internal pure returns (address[] memory pickeds) {\\n    return unsafeToAddresses(pickTopKByValues(toUint256s(keys), values, k));\\n  }\\n\\n  /**\\n   * @dev Picks the top `k` `keys` based on their corresponding `values`.\\n   *\\n   * WARNING: The input array size will be changed. Besides, this fn does not guarantee all elements are sorted\\n   */\\n  function pickTopKByValues(\\n    uint256[] memory keys,\\n    uint256[] memory values,\\n    uint256 k\\n  ) internal pure returns (uint256[] memory pickeds) {\\n    unchecked {\\n      uint256 length = keys.length;\\n      if (k >= length) return keys;\\n\\n      inplaceDescSortByValue(keys, values);\\n      unsafeResize(keys, k);\\n\\n      return keys;\\n    }\\n  }\\n\\n  /**\\n   * @dev Filter the array `keys` by the corresponding `indexMap` with the filter function `filterFn`.\\n   */\\n  function filterByIndexMap(\\n    uint256[] memory keys,\\n    IndexMap memory indexMap,\\n    function(uint256, uint256[] memory) pure returns (bool) filterFn\\n  ) internal pure returns (uint256[] memory filteredKeys) {\\n    return filterBy(keys, indexMap._inner, filterFn);\\n  }\\n\\n  /**\\n   * @dev Filter the array `keys` by the corresponding value array `values` with the filter function `filterFn`.\\n   */\\n  function filterBy(\\n    uint256[] memory keys,\\n    uint256[] memory values,\\n    function(uint256, uint256[] memory) pure returns (bool) filterFn\\n  ) internal pure returns (uint256[] memory filteredKeys) {\\n    unchecked {\\n      uint256 length = keys.length;\\n      filteredKeys = new uint256[](length);\\n      uint256 nFiltered;\\n\\n      for (uint256 i; i < length; ++i) {\\n        if (filterFn(i, values)) {\\n          filteredKeys[nFiltered++] = keys[i];\\n        }\\n      }\\n\\n      unsafeResize(filteredKeys, nFiltered);\\n\\n      return filteredKeys;\\n    }\\n  }\\n\\n  /**\\n   * @dev Sorts array of uint256 `values`.\\n   *\\n   * - Values are sorted in descending order.\\n   *\\n   * WARNING This function DOES modifies the original `values`.\\n   */\\n  function inplaceDescSort(uint256[] memory values) internal pure returns (uint256[] memory sorted) {\\n    return inplaceDescQuickSort(values);\\n  }\\n\\n  /**\\n   * @dev Quick sort `values`.\\n   *\\n   * - Values are sorted in descending order.\\n   *\\n   * WARNING This function modify `values`\\n   */\\n  function inplaceDescQuickSort(uint256[] memory values) internal pure returns (uint256[] memory sorted) {\\n    uint256 length = values.length;\\n    unchecked {\\n      if (length > 1) _inplaceDescQuickSort(values, 0, int256(length - 1));\\n    }\\n\\n    assembly (\\\"memory-safe\\\") {\\n      sorted := values\\n    }\\n  }\\n\\n  /**\\n   * @dev Internal function to perform quicksort on an `values`.\\n   *\\n   * - Values are sorted in descending order.\\n   *\\n   * WARNING This function modify `values`\\n   */\\n  function _inplaceDescQuickSort(uint256[] memory values, int256 left, int256 right) private pure {\\n    unchecked {\\n      if (left < right) {\\n        if (left == right) return;\\n        int256 i = left;\\n        int256 j = right;\\n        uint256 pivot = values[uint256(left + right) >> 1];\\n\\n        while (i <= j) {\\n          while (pivot < values[uint256(i)]) ++i;\\n          while (pivot > values[uint256(j)]) --j;\\n\\n          if (i <= j) {\\n            (values[uint256(i)], values[uint256(j)]) = (values[uint256(j)], values[uint256(i)]);\\n            ++i;\\n            --j;\\n          }\\n        }\\n\\n        if (left < j) _inplaceDescQuickSort(values, left, j);\\n        if (i < right) _inplaceDescQuickSort(values, i, right);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Sorts array of addresses `self` based on `values`.\\n   *\\n   * - Values are sorted in descending order.\\n   *\\n   * WARNING This function DOES modifies the original `self` and `values`.\\n   */\\n  function inplaceDescSortByValue(\\n    address[] memory self,\\n    uint256[] memory values\\n  ) internal pure returns (address[] memory sorted) {\\n    return unsafeToAddresses(inplaceDescQuickSortByValue(toUint256s(self), values));\\n  }\\n\\n  /**\\n   * @dev Resize a memory array.\\n   *\\n   * WARNING: The new length of the array should not be greater than the current length to avoid collision with other already allocated memory.\\n   */\\n  function unsafeResize(uint256[] memory self, uint256 length) internal pure returns (uint256[] memory resized) {\\n    assembly (\\\"memory-safe\\\") {\\n      resized := self\\n      mstore(resized, length)\\n    }\\n  }\\n\\n  /**\\n   * @dev Resize a memory address array.\\n   *\\n   * WARNING: The new length of the array should not be greater than the current length to avoid collision with other already allocated memory.\\n   */\\n  function unsafeResize(address[] memory self, uint256 length) internal pure returns (address[] memory resized) {\\n    return unsafeToAddresses(unsafeResize(toUint256s(self), length));\\n  }\\n\\n  /**\\n   * @dev Sorts `self` based on `values`.\\n   *\\n   * - Values are sorted in descending order.\\n   *\\n   * WARNING This function DOES modifies the original `self` and `values`.\\n   */\\n  function inplaceDescSortByValue(\\n    uint256[] memory self,\\n    uint256[] memory values\\n  ) internal pure returns (uint256[] memory sorted) {\\n    return inplaceDescQuickSortByValue(self, values);\\n  }\\n\\n  /**\\n   * @dev Quick sort `self` based on `values`.\\n   *\\n   * - Values are sorted in descending order.\\n   *\\n   * WARNING This function modify `self` and `values`\\n   */\\n  function inplaceDescQuickSortByValue(\\n    uint256[] memory self,\\n    uint256[] memory values\\n  ) internal pure returns (uint256[] memory sorted) {\\n    uint256 length = self.length;\\n    if (length != values.length) revert ErrLengthMismatch();\\n    unchecked {\\n      if (length > 1) _inplaceDescQuickSortByValue(self, values, 0, int256(length - 1));\\n    }\\n\\n    assembly (\\\"memory-safe\\\") {\\n      sorted := self\\n    }\\n  }\\n\\n  /**\\n   * @dev Internal function to perform quicksort on an `values` based on a corresponding `arr`.\\n   *\\n   * - Values are sorted in descending order.\\n   *\\n   * WARNING This function modify `arr` and `values`\\n   */\\n  function _inplaceDescQuickSortByValue(\\n    uint256[] memory arr,\\n    uint256[] memory values,\\n    int256 left,\\n    int256 right\\n  ) private pure {\\n    unchecked {\\n      if (left == right) return;\\n      int256 i = left;\\n      int256 j = right;\\n      uint256 pivot = values[uint256(left + right) >> 1];\\n\\n      while (i <= j) {\\n        while (pivot < values[uint256(i)]) ++i;\\n        while (values[uint256(j)] < pivot) --j;\\n\\n        if (i <= j) {\\n          (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\\n          (values[uint256(i)], values[uint256(j)]) = (values[uint256(j)], values[uint256(i)]);\\n          ++i;\\n          --j;\\n        }\\n      }\\n\\n      if (left < j) _inplaceDescQuickSortByValue(arr, values, left, j);\\n      if (i < right) _inplaceDescQuickSortByValue(arr, values, i, right);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xe602052be2234f57b7040de8f34aaa934ca1c00d5edec95d607843a16718142a\",\"license\":\"MIT\"},\"contracts/libraries/LibIndexMap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nstruct IndexMap {\\n  uint256[] _inner;\\n}\\n\\nusing LibIndexMap for IndexMap global;\\n\\n/**\\n * @title LibIndexMap\\n * @author TuDo1403\\n * @dev The `IndexMap` is a bitmap that represents the presence or absence of elements at specific indices.\\n * It is implemented as an array of uint256 values, where each element in an array is a bitmap which can represent the presence or absence of an element at a particular index.\\n * Each element in an array of bitmap can represent the presence or absence of 256 elements.\\n * The Presence of a particular index is represented by setting the corresponding bit in the bitmap to 1.\\n * Example:\\n * - Given an array of values: [11, 24, 33, 52]. Returns the indexes of odd numbers.\\n * - The values of odd numbers are: [11, 33]. Therefore, the indices of odd numbers are: [0, 2].\\n * - However, we can save more gas by using a bitmap to represent the indices of odd numbers.\\n * - Index 0 is an odd number, so we set the first bit of the bitmap to 1, (bitmap = 0001)\\n * - Index 2 is an odd number, so we set the third bit of the bitmap to 1, (bitmap = 0100)\\n * - The bitmap for the indices of odd number is: b'0001' | b'0100' = b'0101' = 5 in decimal\\n */\\nlibrary LibIndexMap {\\n  /// @dev Throws if the index is out of bitmap length.\\n  error ErrOutOfRange(uint256 index);\\n\\n  /// @dev Maximum number of bits in an indexmap slot.\\n  uint256 internal constant MAX_BIT = 256;\\n\\n  /**\\n   * @dev Wraps an array of uint256 values into an IndexMap struct.\\n   * @param inner The array of uint256 values to wrap.\\n   * @return The wrapped IndexMap struct.\\n   */\\n  function wrap(uint256[] memory inner) internal pure returns (IndexMap memory) {\\n    return IndexMap(inner);\\n  }\\n\\n  /**\\n   * @dev Creates a indexmap array based on the given number of elements.\\n   * @param numElement The number of elements to create the indexmap for.\\n   * @return indexmap The created indexmap array.\\n   */\\n  function create(uint16 numElement) internal pure returns (IndexMap memory indexmap) {\\n    unchecked {\\n      indexmap._inner = new uint256[](1 + uint256(numElement) / MAX_BIT);\\n    }\\n  }\\n\\n  /**\\n   * @dev Checks if an index is present in the map.\\n   * @param indexmap The map to check.\\n   * @param index The index to check.\\n   * @return A boolean indicating whether the index is present in the map.\\n   */\\n  function contains(IndexMap memory indexmap, uint256 index) internal pure returns (bool) {\\n    unchecked {\\n      uint256 size = MAX_BIT;\\n      // if index is out of range, return false\\n      if (index >= indexmap._inner.length * size) return false;\\n      return (indexmap._inner[index / size] & (1 << (index % size))) != 0;\\n    }\\n  }\\n\\n  /**\\n   * @dev Set of an element in a indexmap based on its value.\\n   *\\n   * - The indexmap is updated in place.\\n   * - Will not check for index out of range of the original array.\\n   *\\n   * @param indexmap The indexmap to record the existence of the element.\\n   * @param index The value to record.\\n   * @return The updated indexmap with recorded existence of the element.\\n   */\\n  function set(IndexMap memory indexmap, uint256 index) internal pure returns (IndexMap memory) {\\n    unchecked {\\n      uint256 size = MAX_BIT;\\n      uint256 pos = index / size;\\n\\n      if (pos >= indexmap._inner.length) revert ErrOutOfRange(index);\\n\\n      indexmap._inner[index / size] |= 1 << (index % size);\\n\\n      return indexmap;\\n    }\\n  }\\n\\n  /**\\n   * @dev Set of elements in a indexmap based on their values.\\n   *\\n   * - The indexmap is updated in place.\\n   * - Will not check for index out of range of the original array.\\n   *\\n   * @param indexmap The indexmap to record the existence of elements.\\n   * @param indices The array of indices to record.\\n   * @return The updated indexmap with recorded existence of elements.\\n   */\\n  function setBatch(IndexMap memory indexmap, uint256[] memory indices) internal pure returns (IndexMap memory) {\\n    unchecked {\\n      uint256 pos;\\n      uint256 size = MAX_BIT;\\n      uint256 length = indices.length;\\n      uint256 bitmapLength = indexmap._inner.length;\\n\\n      for (uint256 i; i < length; ++i) {\\n        pos = indices[i] / size;\\n\\n        if (pos >= bitmapLength) revert ErrOutOfRange(indices[i]);\\n\\n        indexmap._inner[pos] |= 1 << (indices[i] % size);\\n      }\\n\\n      return indexmap;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xce4278abfd4fbdc0de4a7605e8003c248984ed07e8ff3f2eb20183f5f302a6d4\",\"license\":\"MIT\"},\"contracts/ronin/StakingVesting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport \\\"../interfaces/IStakingVesting.sol\\\";\\nimport \\\"../extensions/collections/HasContracts.sol\\\";\\nimport \\\"../extensions/consumers/PercentageConsumer.sol\\\";\\nimport { RONTransferHelper } from \\\"../extensions/RONTransferHelper.sol\\\";\\nimport { HasValidatorDeprecated } from \\\"../utils/DeprecatedSlots.sol\\\";\\nimport \\\"../utils/CommonErrors.sol\\\";\\n\\ncontract StakingVesting is\\n  IStakingVesting,\\n  PercentageConsumer,\\n  HasValidatorDeprecated,\\n  HasContracts,\\n  Initializable,\\n  RONTransferHelper\\n{\\n  /// @dev The block bonus for the block producer whenever a new block is mined.\\n  uint256 internal _blockProducerBonusPerBlock;\\n  /// @dev The block bonus for the bridge operator whenever a new block is mined.\\n  uint256 internal _bridgeOperatorBonusPerBlock;\\n  /// @dev The last block number that the staking vesting sent.\\n  uint256 internal _lastBlockSendingBonus;\\n  /// @dev The percentage that extracted from reward of block producer for fast finality.\\n  uint256 internal _fastFinalityRewardPercentage;\\n\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  /**\\n   * @dev Initializes the contract storage.\\n   */\\n  function initialize(\\n    address validatorContract,\\n    uint256 blockProducerBonusPerBlock,\\n    uint256 bridgeOperatorBonusPerBlock\\n  ) external payable initializer {\\n    _setContract(ContractType.VALIDATOR, validatorContract);\\n    _setBlockProducerBonusPerBlock(blockProducerBonusPerBlock);\\n    _setBridgeOperatorBonusPerBlock(bridgeOperatorBonusPerBlock);\\n  }\\n\\n  function initializeV2() external reinitializer(2) {\\n    _setContract(ContractType.VALIDATOR, ______deprecatedValidator);\\n    delete ______deprecatedValidator;\\n  }\\n\\n  function initializeV3(uint256 fastFinalityRewardPercent) external reinitializer(3) {\\n    _setFastFinalityRewardPercentage(fastFinalityRewardPercent);\\n  }\\n\\n  /**\\n   * @inheritdoc IStakingVesting\\n   */\\n  function receiveRON() external payable { }\\n\\n  /**\\n   * @inheritdoc IStakingVesting\\n   */\\n  function blockProducerBlockBonus(uint256 /* _block */ ) public view override returns (uint256) {\\n    return _blockProducerBonusPerBlock;\\n  }\\n\\n  /**\\n   * @inheritdoc IStakingVesting\\n   */\\n  function bridgeOperatorBlockBonus(uint256 /* _block */ ) public view override returns (uint256) {\\n    return _bridgeOperatorBonusPerBlock;\\n  }\\n\\n  /**\\n   * @inheritdoc IStakingVesting\\n   */\\n  function lastBlockSendingBonus() external view returns (uint256) {\\n    return _lastBlockSendingBonus;\\n  }\\n\\n  /**\\n   * @inheritdoc IStakingVesting\\n   */\\n  function fastFinalityRewardPercentage() external view override returns (uint256) {\\n    return _fastFinalityRewardPercentage;\\n  }\\n\\n  /**\\n   * @inheritdoc IStakingVesting\\n   */\\n  function requestBonus(\\n    bool forBlockProducer,\\n    bool forBridgeOperator\\n  )\\n    external\\n    override\\n    onlyContract(ContractType.VALIDATOR)\\n    returns (bool success, uint256 blockProducerBonus, uint256 bridgeOperatorBonus, uint256 fastFinalityRewardPercent)\\n  {\\n    if (block.number <= _lastBlockSendingBonus) revert ErrBonusAlreadySent();\\n\\n    _lastBlockSendingBonus = block.number;\\n\\n    blockProducerBonus = forBlockProducer ? blockProducerBlockBonus(block.number) : 0;\\n    bridgeOperatorBonus = forBridgeOperator ? bridgeOperatorBlockBonus(block.number) : 0;\\n    fastFinalityRewardPercent = _fastFinalityRewardPercentage;\\n\\n    uint256 totalAmount = blockProducerBonus + bridgeOperatorBonus;\\n\\n    if (totalAmount > 0) {\\n      address payable validatorContractAddr = payable(msg.sender);\\n\\n      success = _unsafeSendRON(validatorContractAddr, totalAmount);\\n\\n      if (!success) {\\n        emit BonusTransferFailed(\\n          block.number, validatorContractAddr, blockProducerBonus, bridgeOperatorBonus, address(this).balance\\n        );\\n        return (success, 0, 0, 0);\\n      }\\n\\n      emit BonusTransferred(block.number, validatorContractAddr, blockProducerBonus, bridgeOperatorBonus);\\n    }\\n  }\\n\\n  /**\\n   * @inheritdoc IStakingVesting\\n   */\\n  function setBlockProducerBonusPerBlock(uint256 amount) external override onlyAdmin {\\n    _setBlockProducerBonusPerBlock(amount);\\n  }\\n\\n  /**\\n   * @inheritdoc IStakingVesting\\n   */\\n  function setBridgeOperatorBonusPerBlock(uint256 amount) external override onlyAdmin {\\n    _setBridgeOperatorBonusPerBlock(amount);\\n  }\\n\\n  /**\\n   * @inheritdoc IStakingVesting\\n   */\\n  function setFastFinalityRewardPercentage(uint256 percent) external override onlyAdmin {\\n    if (percent > _MAX_PERCENTAGE) revert ErrInvalidArguments(msg.sig);\\n    _setFastFinalityRewardPercentage(percent);\\n  }\\n\\n  /**\\n   * @dev Sets the bonus amount per block for block producer.\\n   *\\n   * Emits the event `BlockProducerBonusPerBlockUpdated`.\\n   *\\n   */\\n  function _setBlockProducerBonusPerBlock(uint256 amount) internal {\\n    _blockProducerBonusPerBlock = amount;\\n    emit BlockProducerBonusPerBlockUpdated(amount);\\n  }\\n\\n  /**\\n   * @dev Sets the bonus amount per block for bridge operator.\\n   *\\n   * Emits the event `BridgeOperatorBonusPerBlockUpdated`.\\n   *\\n   */\\n  function _setBridgeOperatorBonusPerBlock(uint256 amount) internal {\\n    _bridgeOperatorBonusPerBlock = amount;\\n    emit BridgeOperatorBonusPerBlockUpdated(amount);\\n  }\\n\\n  /**\\n   * @dev Sets the percent of fast finality reward.\\n   *\\n   * Emits the event `FastFinalityRewardPercentageUpdated`.\\n   *\\n   */\\n  function _setFastFinalityRewardPercentage(uint256 percent) internal {\\n    _fastFinalityRewardPercentage = percent;\\n    emit FastFinalityRewardPercentageUpdated(percent);\\n  }\\n}\\n\",\"keccak256\":\"0x65dca4617806941c5a29987369abe24aa06126c23aba6b46ff44d390d14b70f2\",\"license\":\"MIT\"},\"contracts/utils/CommonErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { ContractType } from \\\"./ContractType.sol\\\";\\nimport { RoleAccess } from \\\"./RoleAccess.sol\\\";\\n\\nerror ErrSyncTooFarPeriod(uint256 period, uint256 latestRewardedPeriod);\\n\\n/**\\n * @dev Error raised when a bridge operator update operation fails.\\n * @param bridgeOperator The address of the bridge operator that failed to update.\\n */\\nerror ErrBridgeOperatorUpdateFailed(address bridgeOperator);\\n\\n/**\\n * @dev Error thrown when an address is expected to be an already created externally owned account (EOA).\\n * This error indicates that the provided address is invalid for certain contract operations that require already created EOA.\\n */\\nerror ErrAddressIsNotCreatedEOA(address addr, bytes32 codehash);\\n\\n/**\\n * @dev Error thrown when attempting to add a bridge operator that already exists in the contract.\\n * This error indicates that the provided bridge operator address is already registered as a bridge operator in the contract.\\n */\\nerror ErrBridgeOperatorAlreadyExisted(address bridgeOperator);\\n\\n/**\\n * @dev The error indicating an unsupported interface.\\n * @param interfaceId The bytes4 interface identifier that is not supported.\\n * @param addr The address where the unsupported interface was encountered.\\n */\\nerror ErrUnsupportedInterface(bytes4 interfaceId, address addr);\\n\\n/**\\n * @dev Error thrown when the return data from a callback function is invalid.\\n * @param callbackFnSig The signature of the callback function that returned invalid data.\\n * @param register The address of the register where the callback function was invoked.\\n * @param returnData The invalid return data received from the callback function.\\n */\\nerror ErrInvalidReturnData(bytes4 callbackFnSig, address register, bytes returnData);\\n\\n/**\\n * @dev Error of set to non-contract.\\n */\\nerror ErrZeroCodeContract(address addr);\\n\\n/**\\n * @dev Error indicating that arguments are invalid.\\n */\\nerror ErrInvalidArguments(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that given address is null when it should not.\\n */\\nerror ErrZeroAddress(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that the provided threshold is invalid for a specific function signature.\\n * @param msgSig The function signature (bytes4) that the invalid threshold applies to.\\n */\\nerror ErrInvalidThreshold(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that a function can only be called by the contract itself.\\n * @param msgSig The function signature (bytes4) that can only be called by the contract itself.\\n */\\nerror ErrOnlySelfCall(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\\n * @param expectedRole The role required to perform the function.\\n */\\nerror ErrUnauthorized(bytes4 msgSig, RoleAccess expectedRole);\\n\\n/**\\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\\n */\\nerror ErrUnauthorizedCall(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\\n * @param msgSig The function signature (bytes4).\\n * @param expectedContractType The contract type required to perform the function.\\n * @param actual The actual address that called to the function.\\n */\\nerror ErrUnexpectedInternalCall(bytes4 msgSig, ContractType expectedContractType, address actual);\\n\\n/**\\n * @dev Error indicating that an array is empty when it should contain elements.\\n */\\nerror ErrEmptyArray();\\n\\n/**\\n * @dev Error indicating a mismatch in the length of input parameters or arrays for a specific function.\\n * @param msgSig The function signature (bytes4) that has a length mismatch.\\n */\\nerror ErrLengthMismatch(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that a proxy call to an external contract has failed.\\n * @param msgSig The function signature (bytes4) of the proxy call that failed.\\n * @param extCallSig The function signature (bytes4) of the external contract call that failed.\\n */\\nerror ErrProxyCallFailed(bytes4 msgSig, bytes4 extCallSig);\\n\\n/**\\n * @dev Error indicating that a function tried to call a precompiled contract that is not allowed.\\n * @param msgSig The function signature (bytes4) that attempted to call a precompiled contract.\\n */\\nerror ErrCallPrecompiled(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that a native token transfer has failed.\\n * @param msgSig The function signature (bytes4) of the token transfer that failed.\\n */\\nerror ErrNativeTransferFailed(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that an order is invalid.\\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid order.\\n */\\nerror ErrInvalidOrder(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that the chain ID is invalid.\\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid chain ID.\\n * @param actual Current chain ID that executing function.\\n * @param expected Expected chain ID required for the tx to success.\\n */\\nerror ErrInvalidChainId(bytes4 msgSig, uint256 actual, uint256 expected);\\n\\n/**\\n * @dev Error indicating that a vote type is not supported.\\n * @param msgSig The function signature (bytes4) of the operation that encountered an unsupported vote type.\\n */\\nerror ErrUnsupportedVoteType(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that the proposal nonce is invalid.\\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid proposal nonce.\\n */\\nerror ErrInvalidProposalNonce(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that a voter has already voted.\\n * @param voter The address of the voter who has already voted.\\n */\\nerror ErrAlreadyVoted(address voter);\\n\\n/**\\n * @dev Error indicating that a signature is invalid for a specific function signature.\\n * @param msgSig The function signature (bytes4) that encountered an invalid signature.\\n */\\nerror ErrInvalidSignatures(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that a relay call has failed.\\n * @param msgSig The function signature (bytes4) of the relay call that failed.\\n */\\nerror ErrRelayFailed(bytes4 msgSig);\\n/**\\n * @dev Error indicating that a vote weight is invalid for a specific function signature.\\n * @param msgSig The function signature (bytes4) that encountered an invalid vote weight.\\n */\\nerror ErrInvalidVoteWeight(bytes4 msgSig);\\n\\n/**\\n * @dev Error indicating that a query was made for an outdated bridge operator set.\\n */\\nerror ErrQueryForOutdatedBridgeOperatorSet();\\n\\n/**\\n * @dev Error indicating that a request is invalid.\\n */\\nerror ErrInvalidRequest();\\n\\n/**\\n * @dev Error indicating that a token standard is invalid.\\n */\\nerror ErrInvalidTokenStandard();\\n\\n/**\\n * @dev Error indicating that a token is not supported.\\n */\\nerror ErrUnsupportedToken();\\n\\n/**\\n * @dev Error indicating that a receipt kind is invalid.\\n */\\nerror ErrInvalidReceiptKind();\\n\\n/**\\n * @dev Error indicating that a receipt is invalid.\\n */\\nerror ErrInvalidReceipt();\\n\\n/**\\n * @dev Error indicating that an address is not payable.\\n */\\nerror ErrNonpayableAddress(address);\\n\\n/**\\n * @dev Error indicating that the period is already processed, i.e. scattered reward.\\n */\\nerror ErrPeriodAlreadyProcessed(uint256 requestingPeriod, uint256 latestPeriod);\\n\\n/**\\n * @dev Error thrown when an invalid vote hash is provided.\\n */\\nerror ErrInvalidVoteHash();\\n\\n/**\\n * @dev Error thrown when querying for an empty vote.\\n */\\nerror ErrQueryForEmptyVote();\\n\\n/**\\n * @dev Error thrown when querying for an expired vote.\\n */\\nerror ErrQueryForExpiredVote();\\n\\n/**\\n * @dev Error thrown when querying for a non-existent vote.\\n */\\nerror ErrQueryForNonExistentVote();\\n\\n/**\\n * @dev Error indicating that the method is only called once per block.\\n */\\nerror ErrOncePerBlock();\\n\\n/**\\n * @dev Error of method caller must be coinbase\\n */\\nerror ErrCallerMustBeCoinbase();\\n\",\"keccak256\":\"0x7e228d0dbe377086fb2f7438b1e79b4e30b4eeb0225036b90a33effc5af06197\",\"license\":\"MIT\"},\"contracts/utils/ContractType.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nenum ContractType {\\n  /*  0 */\\n  UNKNOWN,\\n  /*  1 */\\n  PAUSE_ENFORCER,\\n  /*  2 */\\n  BRIDGE,\\n  /*  3 */\\n  BRIDGE_TRACKING,\\n  /*  4 */\\n  GOVERNANCE_ADMIN,\\n  /*  5 */\\n  MAINTENANCE,\\n  /*  6 */\\n  SLASH_INDICATOR,\\n  /*  7 */\\n  STAKING_VESTING,\\n  /*  8 */\\n  VALIDATOR,\\n  /*  9 */\\n  STAKING,\\n  /* 10 */\\n  RONIN_TRUSTED_ORGANIZATION,\\n  /* 11 */\\n  BRIDGE_MANAGER,\\n  /* 12 */\\n  BRIDGE_SLASH,\\n  /* 13 */\\n  BRIDGE_REWARD,\\n  /* 14 */\\n  FAST_FINALITY_TRACKING,\\n  /* 15 */\\n  PROFILE,\\n  /* 16 */\\n  RANDOM_BEACON\\n}\\n\",\"keccak256\":\"0x2ef1b8fcaa991f1d856ca67d19e8ac1576319c03c874cedcc6a7da1860d65a78\",\"license\":\"MIT\"},\"contracts/utils/DeprecatedSlots.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Deprecated Contracts\\n * @dev These abstract contracts are deprecated and should not be used in new implementations.\\n * They provide functionality related to various aspects of a smart contract but have been marked\\n * as deprecated to indicate that they are no longer actively maintained or recommended for use.\\n * The purpose of these contracts is to preserve the slots for already deployed contracts.\\n */\\ncontract HasSlashIndicatorDeprecated {\\n  /// @custom:deprecated Previously `_slashIndicatorContract` (non-zero value)\\n  address internal ______deprecatedSlashIndicator;\\n}\\n\\ncontract HasStakingVestingDeprecated {\\n  /// @custom:deprecated Previously `_stakingVestingContract` (non-zero value)\\n  address internal ______deprecatedStakingVesting;\\n}\\n\\ncontract HasBridgeDeprecated {\\n  /// @custom:deprecated Previously `_bridgeContract` (non-zero value)\\n  address internal ______deprecatedBridge;\\n}\\n\\ncontract HasValidatorDeprecated {\\n  /// @custom:deprecated Previously `_validatorContract` (non-zero value)\\n  address internal ______deprecatedValidator;\\n}\\n\\ncontract HasStakingDeprecated {\\n  /// @custom:deprecated Previously `_stakingContract` (non-zero value)\\n  address internal ______deprecatedStakingContract;\\n}\\n\\ncontract HasMaintenanceDeprecated {\\n  /// @custom:deprecated Previously `_maintenanceContract` (non-zero value)\\n  address internal ______deprecatedMaintenance;\\n}\\n\\ncontract HasTrustedOrgDeprecated {\\n  /// @custom:deprecated Previously `_trustedOrgContract` (non-zero value)\\n  address internal ______deprecatedTrustedOrg;\\n}\\n\\ncontract HasGovernanceAdminDeprecated {\\n  /// @custom:deprecated Previously `_governanceAdminContract` (non-zero value)\\n  address internal ______deprecatedGovernanceAdmin;\\n}\\n\\ncontract HasBridgeTrackingDeprecated {\\n  /// @custom:deprecated Previously `_bridgeTrackingContract` (non-zero value)\\n  address internal ______deprecatedBridgeTracking;\\n}\\n\",\"keccak256\":\"0xe93504aed9f67a6d399475c7162560f2ac4f793fab5b67fe504fc694ac9a2892\",\"license\":\"MIT\"},\"contracts/utils/IdentityGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { LibArray } from \\\"../libraries/LibArray.sol\\\";\\nimport { IERC165 } from \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport { TransparentUpgradeableProxyV2 } from \\\"../extensions/TransparentUpgradeableProxyV2.sol\\\";\\nimport {\\n  ErrAddressIsNotCreatedEOA,\\n  ErrZeroAddress,\\n  ErrOnlySelfCall,\\n  ErrZeroCodeContract,\\n  ErrUnsupportedInterface\\n} from \\\"./CommonErrors.sol\\\";\\n\\nabstract contract IdentityGuard {\\n  using LibArray for address[];\\n\\n  /// @dev value is equal to keccak256(abi.encode())\\n  /// @dev see: https://eips.ethereum.org/EIPS/eip-1052\\n  bytes32 internal constant CREATED_ACCOUNT_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n  /**\\n   * @dev Modifier to restrict functions to only be called by this contract.\\n   * @dev Reverts if the caller is not this contract.\\n   */\\n  modifier onlySelfCall() virtual {\\n    _requireSelfCall();\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to ensure that the elements in the `arr` array are non-duplicates.\\n   * It calls the internal `_checkDuplicate` function to perform the duplicate check.\\n   *\\n   * Requirements:\\n   * - The elements in the `arr` array must not contain any duplicates.\\n   */\\n  modifier nonDuplicate(address[] memory arr) virtual {\\n    _requireNonDuplicate(arr);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Internal method to check the method caller.\\n   * @dev Reverts if the method caller is not this contract.\\n   */\\n  function _requireSelfCall() internal view virtual {\\n    if (msg.sender != address(this)) revert ErrOnlySelfCall(msg.sig);\\n  }\\n\\n  /**\\n   * @dev Internal function to check if a contract address has code.\\n   * @param addr The address of the contract to check.\\n   * @dev Throws an error if the contract address has no code.\\n   */\\n  function _requireHasCode(address addr) internal view {\\n    if (addr.code.length == 0) revert ErrZeroCodeContract(addr);\\n  }\\n\\n  /**\\n   * @dev Checks if an address is zero and reverts if it is.\\n   * @param addr The address to check.\\n   */\\n  function _requireNonZeroAddress(address addr) internal pure {\\n    if (addr == address(0)) revert ErrZeroAddress(msg.sig);\\n  }\\n\\n  /**\\n   * @dev Check if arr is empty and revert if it is.\\n   * Checks if an array contains any duplicate addresses and reverts if duplicates are found.\\n   * @param arr The array of addresses to check.\\n   */\\n  function _requireNonDuplicate(address[] memory arr) internal pure {\\n    if (arr.hasDuplicate()) revert LibArray.ErrDuplicated(msg.sig);\\n  }\\n\\n  /**\\n   * @dev Internal function to require that the provided address is a created externally owned account (EOA).\\n   * This internal function is used to ensure that the provided address is a valid externally owned account (EOA).\\n   * It checks the codehash of the address against a predefined constant to confirm that the address is a created EOA.\\n   * @notice This method only works with non-state EOA accounts\\n   */\\n  function _requireCreatedEOA(address addr) internal view {\\n    _requireNonZeroAddress(addr);\\n    bytes32 codehash = addr.codehash;\\n    if (codehash != CREATED_ACCOUNT_HASH) revert ErrAddressIsNotCreatedEOA(addr, codehash);\\n  }\\n\\n  /**\\n   * @dev Internal function to require that the specified contract supports the given interface. This method handle in\\n   * both case that the callee is either or not the proxy admin of the caller. If the contract does not support the\\n   * interface `interfaceId` or EIP165, a revert with the corresponding error message is triggered.\\n   *\\n   * @param contractAddr The address of the contract to check for interface support.\\n   * @param interfaceId The interface ID to check for support.\\n   */\\n  function _requireSupportsInterface(address contractAddr, bytes4 interfaceId) internal view {\\n    bytes memory supportsInterfaceParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\\n    (bool success, bytes memory returnOrRevertData) = contractAddr.staticcall(supportsInterfaceParams);\\n    if (!success) {\\n      (success, returnOrRevertData) = contractAddr.staticcall(\\n        abi.encodeCall(TransparentUpgradeableProxyV2.functionDelegateCall, (supportsInterfaceParams))\\n      );\\n      if (!success) revert ErrUnsupportedInterface(interfaceId, contractAddr);\\n    }\\n    if (!abi.decode(returnOrRevertData, (bool))) revert ErrUnsupportedInterface(interfaceId, contractAddr);\\n  }\\n}\\n\",\"keccak256\":\"0x7d525f577b73f76a4327fe3cb6ad410b2fa8ae7c5702b2128bb899cae3ee52b5\",\"license\":\"MIT\"},\"contracts/utils/RoleAccess.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nenum RoleAccess {\\n  /* 0 */\\n  UNKNOWN,\\n  /* 1 */\\n  ADMIN,\\n  /* 2 */\\n  COINBASE,\\n  /* 3 */\\n  GOVERNOR,\\n  /* 4 */\\n  CANDIDATE_ADMIN,\\n  /* 5 */\\n  WITHDRAWAL_MIGRATOR,\\n  /* 6 */\\n  __DEPRECATED_BRIDGE_OPERATOR,\\n  /* 7 */\\n  BLOCK_PRODUCER,\\n  /* 8 */\\n  VALIDATOR_CANDIDATE,\\n  /* 9 */\\n  CONSENSUS,\\n  /* 10 */\\n  TREASURY\\n}\\n\",\"keccak256\":\"0xb4be3fbf480504f85653a3f598dd90b32b1afd1c93de472cfbcc0a0741c1aece\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x1d4afe6cb24200cc4545eed814ecf5847277dfe5d613a1707aad5fceecebcfff\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\",\"keccak256\":\"0xa2b22da3032e50b55f95ec1d13336102d675f341167aa76db571ef7f8bb7975d\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xabf3f59bc0e5423eae45e459dbe92e7052c6983628d39008590edc852a62f94a\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\",\"keccak256\":\"0xc130fe33f1b2132158531a87734153293f6d07bc263ff4ac90e85da9c82c0e27\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967Proxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\\n     */\\n    constructor(\\n        address _logic,\\n        address admin_,\\n        bytes memory _data\\n    ) payable ERC1967Proxy(_logic, _data) {\\n        _changeAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _getAdmin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        _changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeToAndCall(newImplementation, bytes(\\\"\\\"), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeToAndCall(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _getAdmin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\",\"keccak256\":\"0xa6a787e7a901af6511e19aa53e1a00352db215a011d2c7a438d0582dd5da76f9\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2a21b14ff90012878752f230d3ffd5c3405e5938d06c97a7d89c0a64561d0d66\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd6153ce99bcdcce22b124f755e72553295be6abcd63804cfdffceb188b8bef10\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd5c50c54bf02740ebd122ff06832546cb5fa84486d52695a9ccfd11666e0c81d\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \\u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xd15c3e400531f00203839159b2b8e7209c5158b35618f570c695b7e47f12e9f0\",\"license\":\"MIT\"}},\"version\":1}",
  "nonce": 194393,
  "storageLayout": {
    "storage": [
      {
        "astId": 45344,
        "contract": "contracts/ronin/StakingVesting.sol:StakingVesting",
        "label": "______deprecatedValidator",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 106616,
        "contract": "contracts/ronin/StakingVesting.sol:StakingVesting",
        "label": "_initialized",
        "offset": 20,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 106619,
        "contract": "contracts/ronin/StakingVesting.sol:StakingVesting",
        "label": "_initializing",
        "offset": 21,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 24986,
        "contract": "contracts/ronin/StakingVesting.sol:StakingVesting",
        "label": "_blockProducerBonusPerBlock",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 24989,
        "contract": "contracts/ronin/StakingVesting.sol:StakingVesting",
        "label": "_bridgeOperatorBonusPerBlock",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 24992,
        "contract": "contracts/ronin/StakingVesting.sol:StakingVesting",
        "label": "_lastBlockSendingBonus",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 24995,
        "contract": "contracts/ronin/StakingVesting.sol:StakingVesting",
        "label": "_fastFinalityRewardPercentage",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  },
  "timestamp": 1717148297,
  "userdoc": {
    "version": 1,
    "kind": "user"
  }
}